import { Random } from '../../../random/generator/Random';
import { Stream } from '../../../stream/Stream';
import { NextValue } from './NextValue';

/**
 * Abstract class able to generate values on type `T`
 *
 * The values generated by an instance of NextArbitrary can be previewed with {@link sample}.
 * They can be classified with {@link statistics}.
 *
 * @remarks Since 2.15.0
 * @public
 */
export abstract class NextArbitrary<T> {
  /**
   * Generate a value of type `T` along with its context (if any)
   * based on the provided random number generator
   *
   * @param mrng - Random number generator
   * @returns Random value of type `T` and its context
   *
   * @remarks Since 2.15.0
   */
  abstract generate(mrng: Random): NextValue<T>;

  /**
   * Generate a value of type `T` along with its context (if any)
   * based on the provided random number generator
   *
   * @param value - The value to shrink
   * @param context - Its associated context (the one returned by generate)
   * @returns Stream of shrinks for value based on context (if provided)
   *
   * @remarks Since 2.15.0
   */
  abstract shrink(value: T, context?: unknown): Stream<NextValue<T>>;

  /**
   * Create another arbitrary by filtering values against `predicate`
   *
   * All the values produced by the resulting arbitrary
   * satisfy `predicate(value) == true`
   *
   * Be aware that using filter may highly impact the time required to generate a valid entry
   *
   * @example
   * ```typescript
   * const integerGenerator: NextArbitrary<number> = ...;
   * const evenIntegerGenerator: NextArbitrary<number> = integerGenerator.filter(e => e % 2 === 0);
   * // new NextArbitrary only keeps even values
   * ```
   *
   * @param refinement - Predicate, to test each produced element. Return true to keep the element, false otherwise
   * @returns New arbitrary filtered using predicate
   *
   * @remarks Since 2.15.0
   */
  filter<U extends T>(refinement: (t: T) => t is U): NextArbitrary<U>;
  /**
   * Create another arbitrary by filtering values against `predicate`
   *
   * All the values produced by the resulting arbitrary
   * satisfy `predicate(value) == true`
   *
   * Be aware that using filter may highly impact the time required to generate a valid entry
   *
   * @example
   * ```typescript
   * const integerGenerator: NextArbitrary<number> = ...;
   * const evenIntegerGenerator: NextArbitrary<number> = integerGenerator.filter(e => e % 2 === 0);
   * // new NextArbitrary only keeps even values
   * ```
   *
   * @param predicate - Predicate, to test each produced element. Return true to keep the element, false otherwise
   * @returns New arbitrary filtered using predicate
   *
   * @remarks Since 2.15.0
   */
  filter(predicate: (t: T) => boolean): NextArbitrary<T>;
  filter<U extends T>(refinement: (t: T) => t is U): NextArbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new FilterArbitrary(this, refinement);
  }

  /**
   * Create another arbitrary by mapping all produced values using the provided `mapper`
   * Values produced by the new arbitrary are the result of applying `mapper` value by value
   *
   * @example
   * ```typescript
   * const rgbChannels: NextArbitrary<{r:number,g:number,b:number}> = ...;
   * const color: NextArbitrary<string> = rgbChannels.map(ch => `#${(ch.r*65536 + ch.g*256 + ch.b).toString(16).padStart(6, '0')}`);
   * // transform an NextArbitrary producing {r,g,b} integers into an NextArbitrary of '#rrggbb'
   * ```
   *
   * @param mapper - Map function, to produce a new element based on an old one
   * @returns New arbitrary with mapped elements
   *
   * @remarks Since 2.15.0
   */
  map<U>(mapper: (t: T) => U): NextArbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new MapArbitrary(this, mapper);
  }

  /**
   * Create another arbitrary by mapping a value from a base Arbirary using the provided `fmapper`
   * Values produced by the new arbitrary are the result of the arbitrary generated by applying `fmapper` to a value
   * @example
   * ```typescript
   * const arrayAndLimitArbitrary = fc.nat().chain((c: number) => fc.tuple( fc.array(fc.nat(c)), fc.constant(c)));
   * ```
   *
   * @param fmapper - Chain function, to produce a new Arbitrary using a value from another Arbitrary
   * @returns New arbitrary of new type
   *
   * @remarks Since 2.15.0
   */
  chain<U>(fmapper: (t: T) => NextArbitrary<U>): NextArbitrary<U> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new ChainArbitrary(this, fmapper);
  }

  /**
   * Create another NextArbitrary with no shrink values
   *
   * @example
   * ```typescript
   * const dataGenerator: NextArbitrary<string> = ...;
   * const unshrinkableDataGenerator: NextArbitrary<string> = dataGenerator.noShrink();
   * // same values no shrink
   * ```
   *
   * @returns Create another arbitrary with no shrink values
   * @remarks Since 2.15.0
   */
  noShrink(): NextArbitrary<T> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new NoShrinkArbitrary(this);
  }

  /**
   * Create another NextArbitrary having bias - by default return itself
   *
   * @param freq - The biased version will be used one time over freq - if it exists - freq must be superior or equal to 2 to avoid any lock
   * @remarks Since 2.15.0
   */
  withBias(_freq: number): NextArbitrary<T> {
    return this;
  }

  /**
   * Create another NextArbitrary that cannot be biased
   *
   * @param freq - The biased version will be used one time over freq - if it exists
   * @remarks Since 2.15.0
   */
  noBias(): NextArbitrary<T> {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return new NoBiasArbitrary(this);
  }
}

/** @internal */
type ChainArbitraryContext<T, U> = {
  originalValue: T;
  originalContext: unknown;
  chainedArbitrary: NextArbitrary<U>;
  chainedContext: unknown;
  clonedMrng: Random;
};

/** @internal */
class ChainArbitrary<T, U> extends NextArbitrary<U> {
  constructor(readonly arb: NextArbitrary<T>, readonly fmapper: (t: T) => NextArbitrary<U>) {
    super();
  }
  generate(mrng: Random): NextValue<U> {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng);
    return this.valueMapper(src, mrng, clonedMrng);
  }
  shrink(value: U, context?: unknown): Stream<NextValue<U>> {
    if (this.isSafeContext(context)) {
      return this.arb
        .shrink(context.originalValue, context.originalContext)
        .map((v) => this.valueMapper(v, context.clonedMrng.clone(), context.clonedMrng))
        .join(
          context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
            const newContext: ChainArbitraryContext<T, U> = { ...context, chainedContext: dst.context };
            return new NextValue(dst.value_, newContext);
          })
        );
    }
    // TODO Need unfmapper
    return Stream.nil();
  }
  withBias(freq: number): NextArbitrary<U> {
    return this.arb.withBias(freq).chain((t: T) => this.fmapper(t).withBias(freq));
  }
  private valueMapper(v: NextValue<T>, generateMrng: Random, clonedMrng: Random): NextValue<U> {
    const chainedArbitrary = this.fmapper(v.value_);
    const dst = chainedArbitrary.generate(generateMrng);
    const context: ChainArbitraryContext<T, U> = {
      originalValue: v.value_,
      originalContext: v.context,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng,
    };
    return new NextValue(dst.value_, context);
  }
  private isSafeContext(context: unknown): context is ChainArbitraryContext<T, U> {
    return (
      context != null &&
      typeof context === 'object' &&
      'originalValue' in (context as any) &&
      'originalContext' in (context as any) &&
      'chainedArbitrary' in (context as any) &&
      'chainedContext' in (context as any) &&
      'clonedMrng' in (context as any)
    );
  }
}

/** @internal */
type MapArbitraryContext<T> = {
  originalValue: T;
  originalContext: unknown;
};

/** @internal */
class MapArbitrary<T, U> extends NextArbitrary<U> {
  readonly bindValueMapper: (v: NextValue<T>) => NextValue<U>;
  constructor(readonly arb: NextArbitrary<T>, readonly mapper: (t: T) => U) {
    super();
    this.bindValueMapper = this.valueMapper.bind(this);
  }
  generate(mrng: Random): NextValue<U> {
    const g = this.arb.generate(mrng);
    return new NextValue(this.mapper(g.value_));
  }
  shrink(_value: U, context?: unknown): Stream<NextValue<U>> {
    if (this.isSafeContext(context)) {
      return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
    }
    // TODO Need unmapper
    return Stream.nil();
  }
  withBias(freq: number): NextArbitrary<U> {
    return this.arb.withBias(freq).map(this.mapper);
  }
  private valueMapper(v: NextValue<T>): NextValue<U> {
    const context: MapArbitraryContext<T> = { originalValue: v.value_, originalContext: v.context };
    return new NextValue(this.mapper(v.value_), context);
  }
  private isSafeContext(context: unknown): context is MapArbitraryContext<T> {
    return (
      context != null &&
      typeof context === 'object' &&
      'originalValue' in (context as any) &&
      'originalContext' in (context as any)
    );
  }
}

/** @internal */
class FilterArbitrary<T, U extends T> extends NextArbitrary<U> {
  readonly bindRefinementOnValue: (v: NextValue<T>) => v is NextValue<U>;
  constructor(readonly arb: NextArbitrary<T>, readonly refinement: (t: T) => t is U) {
    super();
    this.bindRefinementOnValue = this.refinementOnValue.bind(this);
  }
  generate(mrng: Random): NextValue<U> {
    // eslint-disable-next-line no-constant-condition
    while (true) {
      const g = this.arb.generate(mrng);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  shrink(value: U, context?: unknown): Stream<NextValue<U>> {
    return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
  }
  withBias(freq: number) {
    return this.arb.withBias(freq).filter(this.refinement);
  }
  private refinementOnValue(v: NextValue<T>): v is NextValue<U> {
    return this.refinement(v.value);
  }
}

/** @internal */
class NoShrinkArbitrary<T> extends NextArbitrary<T> {
  constructor(readonly arb: NextArbitrary<T>) {
    super();
  }
  generate(mrng: Random): NextValue<T> {
    return new NextValue(this.arb.generate(mrng).value_);
  }
  shrink(_value: T, _context?: unknown): Stream<NextValue<T>> {
    return Stream.nil();
  }
  withBias(freq: number) {
    return this.arb.withBias(freq).noShrink();
  }
}

/** @internal */
class NoBiasArbitrary<T> extends NextArbitrary<T> {
  constructor(readonly arb: NextArbitrary<T>) {
    super();
  }
  generate(mrng: Random): NextValue<T> {
    return this.arb.generate(mrng);
  }
  shrink(value: T, context?: unknown): Stream<NextValue<T>> {
    return this.arb.shrink(value, context);
  }
}
